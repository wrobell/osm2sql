#!/usr/bin/env python3

#
# osm2sql - script to convert OpenStreetMap data into SQL spatial database.
#
# Copyright (C) 2009 by Artur Wroblewski <wrobell@pld-linux.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#


import lxml.etree as et
import bz2
import os.path
import sys
import bsddb3 as bsddb
import struct

# quote string
# - " -> \\" 
# - \ -> 4 * \
# - \n -> <space>
quote = lambda s: s.replace('\\', '\\\\\\\\') \
    .replace('\'', '\'\'') \
    .replace('"', '\\\\"') \
    .replace('\x0d\x0a', ' ') \
    .replace('\x0d', ' ') \
    .replace('\x0a', ' ')

# format tags into SQL string
get_tags = lambda n: '\'' + (','.join('"{0}" => "{1}"'.format(quote(k), quote(v))
            for k, v in zip(FIND_TAG_K(n), FIND_TAG_V(n)))) + '\''

def print_sql(table, *values):
    """
    Print SQL insert statements for specified table and values.
    """
    print('insert into {} values({});'.format(table, ','.join(values)))


def clear_node(n):
    """
    Clear memory after parsing a node with ElementTree API.
    """
    n.clear()

    parent = n.getparent()
    ps = n.getprevious()
    while ps is not None:
        parent.remove(ps)
        ps = n.getprevious()


FMT_POINT = '\'SRID=4326;POINT({} {})\''.format
FMT_LINE = '\'SRID=4326;LINESTRING({})\''.format
FMT_POLYGON = '\'SRID=4326;POLYGON(({}))\''.format
FMT_ARRAY = lambda l: 'array[{}]'.format(','.join(l))

FIND_TAG_K = et.XPath('tag/@k')
FIND_TAG_V = et.XPath('tag/@v')
FIND_NODE_ID = et.XPath('nd/@ref')

print("""
begin;

drop table if exists osm_point;
drop table if exists osm_line;
drop table if exists osm_area;

create table osm_point (
    id bigint,
    tags hstore,
    primary key (id)
);
select AddGeometryColumn('osm_point', 'location', 4326, 'POINT', 2);
create index idx_osm_point_t on osm_point using gin (tags);

create table osm_line (
    id bigint,
    tags hstore,
    points bigint[],
    primary key (id)
);
select AddGeometryColumn('osm_line', 'shape', 4326, 'LINESTRING', 2);
create index idx_osm_line_t on osm_line using gin (tags);

create table osm_area (
    id bigint,
    tags hstore,
    points bigint[],
    primary key (id)
);
select AddGeometryColumn('osm_area', 'shape', 4326, 'POLYGON', 2);
create index idx_osm_area_t on osm_area using gin (tags);

""")

fin = sys.argv[1]
if os.path.splitext(fin)[1] == '.bz2':
    fin = bz2.BZ2File(fin)

f = et.iterparse(fin)
cachesize = 512 * 1024 ** 2
#idx = bsddb.hashopen('osm.idx', 'n', cachesize=cachesize)
idx = bsddb.btopen('osm.idx', 'n', cachesize=cachesize)
cnt = 0
for _, n in f:
    if n.tag == 'node':
        cnt += 1
        id = n.get('id').encode()
        #pt = '{} {}'.format(n.get('lon'), n.get('lat'))
        pt = struct.pack('ff', float(n.get('lon')), float(n.get('lat')))
        #tags = get_tags(n)
        idx[id] = pt

        clear_node(n)
        if cnt % 100000 == 0:
            import datetime
            print('node', cnt, datetime.datetime.now(), file=sys.stderr)

    elif n.tag == 'way':
        cnt += 1
        id = n.get('id')
        tags = get_tags(n)
        p_id = [p for p in FIND_NODE_ID(n)]
        p_g = ','.join('{} {}'.format(*struct.unpack('ff', idx[p.encode()])) for p in p_id)
        if len(p_id) > 1 and p_id[0] != p_id[-1]:
            print_sql('osm_line', id, tags, FMT_ARRAY(p_id), FMT_LINE(p_g))
        elif len(p_id) > 3 and p_id[0] == p_id[-1]:
            print_sql('osm_area', id, tags, FMT_ARRAY(p_id), FMT_POLYGON(p_g))

        #points = ','.join((idx[p.encode()].decode() for p in FIND_NODE_ID(n)))
        #print('\t'.join((id, tags, points)))

        clear_node(n)
        if cnt % 100000 == 0:
            import datetime
            print('waypoint', cnt, datetime.datetime.now(), file=sys.stderr)

    elif n.tag == 'relation':
        break
    elif n.tag == 'changeset':
        clear_node(n)
        continue

print('commit;')

# vim: sw=4:et:ai
