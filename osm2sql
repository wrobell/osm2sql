#!/usr/bin/env python3

#
# osm2sql - script to convert OpenStreetMap data into SQL spatial database.
#
# Copyright (C) 2009 by Artur Wroblewski <wrobell@pld-linux.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#


import lxml.etree as et
import bz2
import os.path
import sys

# quote string
# - " -> \\" 
# - \ -> 4 * \
# - \n -> <space>
quote = lambda s: s.replace('\\', '\\\\\\\\') \
    .replace('"', '\\\\"') \
    .replace('\x0d\x0a', ' ') \
    .replace('\x0d', ' ') \
    .replace('\x0a', ' ')

get_tags = lambda n: ','.join('"{0}" => "{1}"'.format(quote(k), quote(v))
            for k, v in zip(FIND_TAG_K(n), FIND_TAG_V(n)))

def clear_node(n):
    """
    Clear memory after parsing a node with ElementTree API.
    """
    n.clear()

    parent = n.getparent()
    ps = n.getprevious()
    while ps is not None:
        parent.remove(ps)
        ps = n.getprevious()


FMT_POINT = 'SRID=4326;POINT({} {})'.format

FIND_TAG_K = et.XPath('tag/@k')
FIND_TAG_V = et.XPath('tag/@v')
FIND_NODE_ID = et.XPath('nd/@ref')

print("""
begin;

drop index if exists _idx_osm_node_t;
drop index if exists _idx_osm_way_t;
drop table if exists _osm_node;
drop table if exists _osm_way;

drop table if exists osm_point;
drop table if exists osm_line;
drop table if exists osm_area;

-- temporary tables
create table _osm_node (
    id bigint,
    tags hstore,
    primary key (id)
);
select AddGeometryColumn('_osm_node', 'location', 4326, 'POINT', 2);
create index _idx_osm_node_t on _osm_node using gin (tags);

create table _osm_way (
    id bigint,
    tags hstore,
    points bigint[],
    primary key (id)
);
create index _idx_osm_way_t on _osm_way using gin (tags);


create table osm_point (
    id bigint,
    tags hstore,
    primary key (id)
);
select AddGeometryColumn('osm_point', 'location', 4326, 'POINT', 2);
create index idx_osm_point_t on osm_point using gin (tags);

create table osm_line (
    id bigint,
    tags hstore,
    points bigint[],
    primary key (id)
);
select AddGeometryColumn('osm_line', 'shape', 4326, 'LINESTRING', 2);
create index idx_osm_line_t on osm_line using gin (tags);

create table osm_area (
    id bigint,
    tags hstore,
    points bigint[],
    primary key (id)
);
select AddGeometryColumn('osm_area', 'shape', 4326, 'POLYGON', 2);
create index idx_osm_area_t on osm_area using gin (tags);

""")

fin = sys.argv[1]
if os.path.splitext(fin)[1] == '.bz2':
    fin = bz2.BZ2File(fin)

last = ''
f = et.iterparse(fin)
print("copy _osm_node (id, location, tags) from stdin with null as \'\';")
for _, n in f:
    if n.tag == 'node':
        id = n.get('id')
        pt = FMT_POINT(n.get('lon'), n.get('lat'))
        tags = get_tags(n)
        print('\t'.join((id, pt, tags)))

        last = 'node'
        clear_node(n)

    elif n.tag == 'way':
        if last == 'node':
            print('\.\n')
            print('copy _osm_way (id, tags, points) from stdin with null as \'\';')

        id = n.get('id')
        tags = get_tags(n)
        points = '{' + ','.join(FIND_NODE_ID(n)) + '}'
        print('\t'.join((id, tags, points)))

        last = 'way'
        clear_node(n)

    elif n.tag == 'relation':
        break
    elif n.tag == 'changeset':
        clear_node(n)
        continue

print('\.')
print("""
insert into osm_line (id, tags, points, shape)
select ol.id, ol.tags,
    array_agg(ol.points) as points,
    st_makeline(op.location) as shape
from (
    select id, tags, unnest(points) as points
    from _osm_way ol
    where array_length(points, 1) > 1
        and points[1] <> points[array_length(points, 1)]
) ol inner join _osm_node op on ol.points = op.id
group by 1, 2;

insert into osm_area (id, tags, points, shape)
select ol.id, ol.tags,
    array_agg(ol.points) as points,
    st_makepolygon(st_makeline(op.location)) as shape
from (
    select id, tags, unnest(points) as points
    from _osm_way ol
    where array_length(points, 1) >= 4
        and points[1] = points[array_length(points, 1)]
) ol inner join _osm_node op on ol.points = op.id
group by 1, 2;

drop index _idx_osm_node_t;
drop index _idx_osm_way_t;
drop table _osm_node;
drop table _osm_way;
""")
print('commit;')

# vim: sw=4:et:ai
